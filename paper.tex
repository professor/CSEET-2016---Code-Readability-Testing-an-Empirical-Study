%% bare_conf.tex
%% V1.4b
%% 2015/08/26
%% by Michael Shell
%% See:
%% http://www.michaelshell.org/
%% for current contact information.
%%
%% This is a skeleton file demonstrating the use of IEEEtran.cls
%% (requires IEEEtran.cls version 1.8b or later) with an IEEE
%% conference paper.
%%
%% Support sites:
%% http://www.michaelshell.org/tex/ieeetran/
%% http://www.ctan.org/pkg/ieeetran
%% and
%% http://www.ieee.org/

%%*************************************************************************
%% Legal Notice:
%% This code is offered as-is without any warranty either expressed or
%% implied; without even the implied warranty of MERCHANTABILITY or
%% FITNESS FOR A PARTICULAR PURPOSE! 
%% User assumes all risk.
%% In no event shall the IEEE or any contributor to this code be liable for
%% any damages or losses, including, but not limited to, incidental,
%% consequential, or any other damages, resulting from the use or misuse
%% of any information contained here.
%%
%% All comments are the opinions of their respective authors and are not
%% necessarily endorsed by the IEEE.
%%
%% This work is distributed under the LaTeX Project Public License (LPPL)
%% ( http://www.latex-project.org/ ) version 1.3, and may be freely used,
%% distributed and modified. A copy of the LPPL, version 1.3, is included
%% in the base LaTeX documentation of all distributions of LaTeX released
%% 2003/12/01 or later.
%% Retain all contribution notices and credits.
%% ** Modified files should be clearly indicated as such, including  **
%% ** renaming them and changing author support contact information. **
%%*************************************************************************


% *** Authors should verify (and, if needed, correct) their LaTeX system  ***
% *** with the testflow diagnostic prior to trusting their LaTeX platform ***
% *** with production work. The IEEE's font choices and paper sizes can   ***
% *** trigger bugs that do not appear when using other class files.       ***                          ***
% The testflow support page is at:
% http://www.michaelshell.org/tex/testflow/



\documentclass[conference]{IEEEtran}
% Some Computer Society conferences also require the compsoc mode option,
% but others use the standard conference format.
%
% If IEEEtran.cls has not been installed into the LaTeX system files,
% manually specify the path to it like:
% \documentclass[conference]{../sty/IEEEtran}





% Some very useful LaTeX packages include:
% (uncomment the ones you want to load)


% *** MISC UTILITY PACKAGES ***
%
%\usepackage{ifpdf}
% Heiko Oberdiek's ifpdf.sty is very useful if you need conditional
% compilation based on whether the output is pdf or dvi.
% usage:
% \ifpdf
%   % pdf code
% \else
%   % dvi code
% \fi
% The latest version of ifpdf.sty can be obtained from:
% http://www.ctan.org/pkg/ifpdf
% Also, note that IEEEtran.cls V1.7 and later provides a builtin
% \ifCLASSINFOpdf conditional that works the same way.
% When switching from latex to pdflatex and vice-versa, the compiler may
% have to be run twice to clear warning/error messages.



%Todd added for strike-outs
\usepackage{ulem}
%Todd added for decreasing an enumerated list
\usepackage{etaremune}


% *** CITATION PACKAGES ***
%
%\usepackage{cite}
% cite.sty was written by Donald Arseneau
% V1.6 and later of IEEEtran pre-defines the format of the cite.sty package
% \cite{} output to follow that of the IEEE. Loading the cite package will
% result in citation numbers being automatically sorted and properly
% "compressed/ranged". e.g., [1], [9], [2], [7], [5], [6] without using
% cite.sty will become [1], [2], [5]--[7], [9] using cite.sty. cite.sty's
% \cite will automatically add leading space, if needed. Use cite.sty's
% noadjust option (cite.sty V3.8 and later) if you want to turn this off
% such as if a citation ever needs to be enclosed in parenthesis.
% cite.sty is already installed on most LaTeX systems. Be sure and use
% version 5.0 (2009-03-20) and later if using hyperref.sty.
% The latest version can be obtained at:
% http://www.ctan.org/pkg/cite
% The documentation is contained in the cite.sty file itself.






% *** GRAPHICS RELATED PACKAGES ***
%
\ifCLASSINFOpdf
   \usepackage[pdftex]{graphicx}
  % declare the path(s) where your graphic files are
  % \graphicspath{{../pdf/}{../jpeg/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
   \DeclareGraphicsExtensions{.pdf,.jpeg,.png}
\else
  % or other class option (dvipsone, dvipdf, if not using dvips). graphicx
  % will default to the driver specified in the system graphics.cfg if no
  % driver is specified.
  % \usepackage[dvips]{graphicx}
  % declare the path(s) where your graphic files are
  % \graphicspath{{../eps/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  % \DeclareGraphicsExtensions{.eps}
\fi
% graphicx was written by David Carlisle and Sebastian Rahtz. It is
% required if you want graphics, photos, etc. graphicx.sty is already
% installed on most LaTeX systems. The latest version and documentation
% can be obtained at: 
% http://www.ctan.org/pkg/graphicx
% Another good source of documentation is "Using Imported Graphics in
% LaTeX2e" by Keith Reckdahl which can be found at:
% http://www.ctan.org/pkg/epslatex
%
% latex, and pdflatex in dvi mode, support graphics in encapsulated
% postscript (.eps) format. pdflatex in pdf mode supports graphics
% in .pdf, .jpeg, .png and .mps (metapost) formats. Users should ensure
% that all non-photo figures use a vector format (.eps, .pdf, .mps) and
% not a bitmapped formats (.jpeg, .png). The IEEE frowns on bitmapped formats
% which can result in "jaggedy"/blurry rendering of lines and letters as
% well as large increases in file sizes.
%
% You can find documentation about the pdfTeX application at:
% http://www.tug.org/applications/pdftex





% *** MATH PACKAGES ***
%
%\usepackage{amsmath}
% A popular package from the American Mathematical Society that provides
% many useful and powerful commands for dealing with mathematics.
%
% Note that the amsmath package sets \interdisplaylinepenalty to 10000
% thus preventing page breaks from occurring within multiline equations. Use:
%\interdisplaylinepenalty=2500
% after loading amsmath to restore such page breaks as IEEEtran.cls normally
% does. amsmath.sty is already installed on most LaTeX systems. The latest
% version and documentation can be obtained at:
% http://www.ctan.org/pkg/amsmath





% *** SPECIALIZED LIST PACKAGES ***
%
%\usepackage{algorithmic}
% algorithmic.sty was written by Peter Williams and Rogerio Brito.
% This package provides an algorithmic environment fo describing algorithms.
% You can use the algorithmic environment in-text or within a figure
% environment to provide for a floating algorithm. Do NOT use the algorithm
% floating environment provided by algorithm.sty (by the same authors) or
% algorithm2e.sty (by Christophe Fiorio) as the IEEE does not use dedicated
% algorithm float types and packages that provide these will not provide
% correct IEEE style captions. The latest version and documentation of
% algorithmic.sty can be obtained at:
% http://www.ctan.org/pkg/algorithms
% Also of interest may be the (relatively newer and more customizable)
% algorithmicx.sty package by Szasz Janos:
% http://www.ctan.org/pkg/algorithmicx




% *** ALIGNMENT PACKAGES ***
%
%\usepackage{array}
% Frank Mittelbach's and David Carlisle's array.sty patches and improves
% the standard LaTeX2e array and tabular environments to provide better
% appearance and additional user controls. As the default LaTeX2e table
% generation code is lacking to the point of almost being broken with
% respect to the quality of the end results, all users are strongly
% advised to use an enhanced (at the very least that provided by array.sty)
% set of table tools. array.sty is already installed on most systems. The
% latest version and documentation can be obtained at:
% http://www.ctan.org/pkg/array


% IEEEtran contains the IEEEeqnarray family of commands that can be used to
% generate multiline equations as well as matrices, tables, etc., of high
% quality.




% *** SUBFIGURE PACKAGES ***
%\ifCLASSOPTIONcompsoc
%  \usepackage[caption=false,font=normalsize,labelfont=sf,textfont=sf]{subfig}
%\else
%  \usepackage[caption=false,font=footnotesize]{subfig}
%\fi
% subfig.sty, written by Steven Douglas Cochran, is the modern replacement
% for subfigure.sty, the latter of which is no longer maintained and is
% incompatible with some LaTeX packages including fixltx2e. However,
% subfig.sty requires and automatically loads Axel Sommerfeldt's caption.sty
% which will override IEEEtran.cls' handling of captions and this will result
% in non-IEEE style figure/table captions. To prevent this problem, be sure
% and invoke subfig.sty's "caption=false" package option (available since
% subfig.sty version 1.3, 2005/06/28) as this is will preserve IEEEtran.cls
% handling of captions.
% Note that the Computer Society format requires a larger sans serif font
% than the serif footnote size font used in traditional IEEE formatting
% and thus the need to invoke different subfig.sty package options depending
% on whether compsoc mode has been enabled.
%
% The latest version and documentation of subfig.sty can be obtained at:
% http://www.ctan.org/pkg/subfig




% *** FLOAT PACKAGES ***
%
%\usepackage{fixltx2e}
% fixltx2e, the successor to the earlier fix2col.sty, was written by
% Frank Mittelbach and David Carlisle. This package corrects a few problems
% in the LaTeX2e kernel, the most notable of which is that in current
% LaTeX2e releases, the ordering of single and double column floats is not
% guaranteed to be preserved. Thus, an unpatched LaTeX2e can allow a
% single column figure to be placed prior to an earlier double column
% figure.
% Be aware that LaTeX2e kernels dated 2015 and later have fixltx2e.sty's
% corrections already built into the system in which case a warning will
% be issued if an attempt is made to load fixltx2e.sty as it is no longer
% needed.
% The latest version and documentation can be found at:
% http://www.ctan.org/pkg/fixltx2e


%\usepackage{stfloats}
% stfloats.sty was written by Sigitas Tolusis. This package gives LaTeX2e
% the ability to do double column floats at the bottom of the page as well
% as the top. (e.g., "\begin{figure*}[!b]" is not normally possible in
% LaTeX2e). It also provides a command:
%\fnbelowfloat
% to enable the placement of footnotes below bottom floats (the standard
% LaTeX2e kernel puts them above bottom floats). This is an invasive package
% which rewrites many portions of the LaTeX2e float routines. It may not work
% with other packages that modify the LaTeX2e float routines. The latest
% version and documentation can be obtained at:
% http://www.ctan.org/pkg/stfloats
% Do not use the stfloats baselinefloat ability as the IEEE does not allow
% \baselineskip to stretch. Authors submitting work to the IEEE should note
% that the IEEE rarely uses double column equations and that authors should try
% to avoid such use. Do not be tempted to use the cuted.sty or midfloat.sty
% packages (also by Sigitas Tolusis) as the IEEE does not format its papers in
% such ways.
% Do not attempt to use stfloats with fixltx2e as they are incompatible.
% Instead, use Morten Hogholm'a dblfloatfix which combines the features
% of both fixltx2e and stfloats:
%
% \usepackage{dblfloatfix}
% The latest version can be found at:
% http://www.ctan.org/pkg/dblfloatfix




% *** PDF, URL AND HYPERLINK PACKAGES ***
%
%\usepackage{url}
% url.sty was written by Donald Arseneau. It provides better support for
% handling and breaking URLs. url.sty is already installed on most LaTeX
% systems. The latest version and documentation can be obtained at:
% http://www.ctan.org/pkg/url
% Basically, \url{my_url_here}.




% *** Do not adjust lengths that control margins, column widths, etc. ***
% *** Do not use packages that alter fonts (such as pslatex).         ***
% There should be no need to do such things with IEEEtran.cls V1.6 and later.
% (Unless specifically asked to do so by the journal or conference you plan
% to submit to, of course. )


% correct bad hyphenation here
\hyphenation{op-tical net-works semi-conduc-tor}


\begin{document}
%
% paper title
% Titles are generally capitalized except for words such as a, an, and, as,
% at, but, by, for, in, nor, of, on, or, the, to and up, which are usually
% not capitalized unless they are the first or last word of the title.
% Linebreaks \\ can be used within to get better formatting as desired.
% Do not put math or special symbols in the title.
\title{CSEET 2016 - Code Readability Testing, an Empirical Study}


% author names and affiliations
% use a multiple column layout for up to three different
% affiliations
\author{\IEEEauthorblockN{Todd Sedano}
\IEEEauthorblockA{Carnegie Mellon Unveristy \\
Silicon Valley Campus\\
Moffett Field, CA 94035, USA \\
Email: todd.sedano@sv.cmu.edu
}}

% conference papers do not typically use \thanks and this command
% is locked out in conference mode. If really needed, such as for
% the acknowledgment of grants, issue a \IEEEoverridecommandlockouts
% after \documentclass

% for over three affiliations, or if they all won't fit within the width
% of the page, use this alternative format:
% 
%\author{\IEEEauthorblockN{Michael Shell\IEEEauthorrefmark{1},
%Homer Simpson\IEEEauthorrefmark{2},
%James Kirk\IEEEauthorrefmark{3}, 
%Montgomery Scott\IEEEauthorrefmark{3} and
%Eldon Tyrell\IEEEauthorrefmark{4}}
%\IEEEauthorblockA{\IEEEauthorrefmark{1}School of Electrical and Computer Engineering\\
%Georgia Institute of Technology,
%Atlanta, Georgia 30332--0250\\ Email: see http://www.michaelshell.org/contact.html}
%\IEEEauthorblockA{\IEEEauthorrefmark{2}Twentieth Century Fox, Springfield, USA\\
%Email: homer@thesimpsons.com}
%\IEEEauthorblockA{\IEEEauthorrefmark{3}Starfleet Academy, San Francisco, California 96678-2391\\
%Telephone: (800) 555--1212, Fax: (888) 555--1212}
%\IEEEauthorblockA{\IEEEauthorrefmark{4}Tyrell Inc., 123 Replicant Street, Los Angeles, California 90210--4321}}




% use for special paper notices
%\IEEEspecialpapernotice{(Invited Paper)}




% make the title area
\maketitle

% As a general rule, do not put math, special symbols or citations
% in the abstract
\begin{abstract}
Context: A substantial portion of the cost of software during its life cycle is consumed not in its development, but in its ongoing maintenance. One of the factors that leads to improved code maintainability is its readability. When code is difficult to read, it is difficult for subsequent developers to understand its flow and its side effects, and they are likely to introduce new bugs while trying to fix old ones or while extending the code’s original functionality. But how do software developers know they have written readable code?

Objective: This paper presents a new technique, Code Readability Testing, to determine whether code is readable and evaluates whether the technique increases programmers’ ability to write readable code.

Method: The researcher conducted a field study using 21 software engineering master students and followed the Code Readability Testing with each student in four separate sessions evaluating different ``production ready" software. After the observations, a questionnaire evaluated the programmer’s perspective.

Results: By following Code Readability Testing, half of the programmers writing ``unreadable" code started writing ``readable" code after four sessions. Programmers writing ``readable" code also improved their ability to write readable code. The study reveals that the most frequent suggestions for increasing code readability are improving variable names, improving method names, creating new methods in order to reduce code duplication, simplifying if conditions and structures, and simplifying loop conditions. The programmers report that readability testing is worth their time. They observe increases in their ability to write readable code. When programmers experience a reader struggling to understand their code, they become motivated to write readable code.

Conclusion: This paper defines code readability, demonstrates that Code Readability Testing improves programmers’ ability to write readable code, and identifies frequent fixes needed to improve code readability.
\end{abstract}

% no keywords




% For peer review papers, you can put extra information on the cover
% page as needed:
% \ifCLASSOPTIONpeerreview
% \begin{center} \bfseries EDICS Category: 3-BBND \end{center}
% \fi
%
% For peerreview papers, this IEEEtran command inserts a page break and
% creates the second title. It will be ignored for other modes.
\IEEEpeerreviewmaketitle

\section{Introduction}
Writing readable code reduces the costs of development and maintenance of software systems. A considerable portion of the software development cost is ongoing maintenance to add new features and fix defects \cite{BrooksMythicalManMonth}. Even in the early stages of the software’s evolution, the ability to read and quickly understand existing code is a key factor that affects the code’s ability to change.

While creating programmers who write readable code is not a new problem for the software industry, the previous work focuses around what code should look like, not how to train programmers to write readable code. Developers realize the importance of writing code that is readable by their peers, but they often do not receive feedback on whether their code is readable. Programming constructs that are clear to the author can confuse the next developer. Some programmers bemoan that they can’t read their own code six months later. If the code works, clearly the computer can understand it, but can anyone else on the team?

Teaching this skill is not a top priority in computer science and software engineering curricula. The Computer Science Curriculum promotes understanding the programming paradigms of a particular language (e.g. functional vs. nonfunctional), not how to write readable code [12]. The Software Engineering Body of Knowledge (SWEBOK) does make one reference to writing ``understandable code" in the Coding Practical Considerations for the Software Construction knowledge area [6]. This is just one out of 229 subtopics of SWEBOK. The Graduate Software Engineering reference curriculum (GSwE) does not prescribe any further recommendations beyond SWEBOK for this topic [25]. Some undergraduate courses briefly cover the issues of programming style. A few courses will penalize students for producing unreadable code. In rare courses, students swap assignments simulating the experience of inheriting someone else’s code. While this sensitizes students to the needs of writing readable code, the experience lacks concrete steps to increase their skill. The emphasis of a computer science curriculum or a software engineering curriculum is on the substantial topics in the reference curriculum.
Companies tend to assume programmers arrive with this skill or will learn it through on the job training. Project teams may have code style guidelines, or best practices around writing code e.g. when a programmer opens a database connection, immediately write the close statement.

There is strong empirical evidence that supports the effectiveness of software inspections and code reviews for uncovering bugs. While theses techniques can identify readability issues, they are not designed to teach developers how to write readable code. When an author receives a list of defects, the author looses the opportunity to learn how the code confuses the reader.

Code Readability Testing reveals areas where the code is not readable, and enables a dialogue between coder and reader. Feedback is instantaneous, as the author sees exactly how reader interprets the code.

\subsubsection{Research Objectives}
Using the goal template from Goal Question Metric (GQM), the goal is to...
\textbf{Analyze} Code Readability Testing \textbf{for the purpose of} determining its effectiveness in improving programmers’ ability to write readable code \textbf{with respect to} their effectiveness \textbf{from the point of view of the} researcher \textbf{in the context of} the ``craft of software development" course at Carnegie Mellon University.
This paper decomposes this goal into four questions:
Research Question 1: Would programmers who repeatedly follow Code Readability Testing increase the readability of their code?
Research Question 2: What kinds of issues does Code Readability Testing detect?
Research Question 3: How time-consuming is readability testing?
Research Question 4: How did programmers perceive Code Readability Testing?


\section{Background and Related Work}
Improving code readability and programming style is not a new topic for the software industry.

In their seminal 1974 book, \underline{The Elements of Programming Style}, Kernighan and Plauger document heuristics for improving coding practices and code readability by rewriting code used in computer science textbooks [19]. In the 1982 book, \underline{Understanding the Professional Programmer}, Gerald Weinberg emphasizes that the programmer is a more important reader of the code than the computer’s compiler or interpreter. He suggests that just like the writing process for English text, code needs to be rewritten several times before it becomes exemplary code. He encourages programmers to spend time reworking code that will be frequently read in the future [30].

In recent books aimed at professional programmers, Andrew Hunt, David Thomas, Kent Beck, and Robert Martin tackle the coding style in a variety of ways. In \underline{Pragmatic Programmers}, Hunt and Thomas examine the tools, processes, and tricks that help programmers master their craft [17]. In \underline{Clean Code}, Robert Martin addresses techniques to help a developer become a better programmer [22]. In \underline{Implementation Patterns}, Kent Beck addresses good software development design patterns [3]. In short, they distill their life long experiences into best practices, some of which address code readability.

In recent studies, researchers examine code readability from different approaches: automated improvement techniques, naming of identifiers, syntax, and automated metrics. Several studies attempt to automate techniques to improve code readability. Wang examines the automatic insertion of blank lines in code to improve readability [29] whereas Sasaki reorders programming statements to improve readability by declaring variables immediately before their utilization [27]. Several researchers examine the naming of identifiers [5, 9, 21, 26]. Relf’s tool encourages the developer to improve variable and method names [26]. Binkley observes that camel case is easier to read than underscore variables [4]. Jones looks at the issues with operator precedence in code readability [18].

While human assessment remains the gold standard of code readability, automated metrics often serve as a proxy. Several studies strive to create code readability metrics so that a computer program determines the readability [8, 14, 24].

Incorporating these metrics into static analysis tools, development environments, and IDEs provides an inexpensive assessment. Substituting the computer for a human produces problems. Metrics using character counts or dictionary words might score a variable named ``something_confusing" or ``something_vague" as equally readable as a variable that is ``exactly_what_i_mean." While a statistical approach to readability metrics is helpful, these measures do not reveal the programmer’s intention.

\subsection{Comparison to other techniques}
Fagan Inspections, Code Reviews and Pair Programming are other techniques that improve code quality as summarized in Table 1. Fagan Inspections are a proven, time intensive process for finding defects where a committee of developers reviews code [15]. Inspections often include programming style guides and coding standards. While the author is present, the emphasis is on defect identification, not revealing why reviewers might be confused by the code. Code Reviews are a popular, light-weight process where one developer reviews code before it is committed to the master branch or trunk of a source code management system [11]. The author receives a list of suggested changes or issues to fix. Since the author is not present, the author does not see the process the reviewer goes through to understand the code. Developers primarily use code reviews for bug detection [1, 11], not for training developers how to write readable code. Pair programming occurs when two developers write the code at the same time. Pair programming enables continuous reviewing of code, but doesn’t provide a fresh perspective to reveal issues for which the authors are blind to observe. [10] Resistance to adoption comes either from management who sees it as more expensive than solo programming or from programmers who do not like the social implications of the process.

Note: Bacchelli and Bird report that programmers thought the purpose of code reviews is to find defects, when in reality the programmers are increasing their understanding of the code [1]. If this is the main benefit of code reviews, it is possible to design other mechanisms to increase code understandability more efficiently than the code review technique.

Perspective-Based-Reading reviews requirements documents from prescribed roles such as user, developer, and tester [2]. A developer will convert requirements into a design and a tester converts requirements into a test plan in order to determine if there are omissions and defects in the requirements.

Yet the question remains, ``Can the relevant community understand and maintain the code?" Thus we can ask ourselves, ``how do we know if our code is readable?"

\section{Code Readability Testing}
The technique proposed here uses an experienced programmer to read code samples by thinking out loud and expressing the reader’s thought process in understanding the code. During the session, the author of the code observes if and where difficulties emerge. At the end of the session, the two programmers discuss approaches to improve code readability. This process reveals to the code author how another programmer parses and understands the author’s code [28].
\begin{enumerate}
  \item The author tells the reader the main use case, story card, or functionality produced. The author does not explain the design or the code.
  \item The author indicates which files were added or modified. Starting with test cases helps the reader understand how the code is used by client code.
  \item The reader reads the code aloud and explains the reader’s mental thought process. If the code is unclear, the reader speculates on the intention of the code. The reader verbally describes how he or she thinks the code works and explains his or her thought process. Voicing questions helps focus the reader and author. If the reader does not understand a line of code due to unfamiliar programming syntax, the reader asks the author what the operation does.
  \item The author does not respond to what the reader is thinking or asking. The author can take notes about what makes particular sections confusing.
  \item At the end, the reader confirms with the author that the reader properly understands the code. The author then asks the reader any clarifying questions about the experience.
  \item The author and the reader discuss how to improve the code.
\end{enumerate}

The Usability Testing technique [23] from Human Computer Interaction serves as a model for this process. In usability testing, user experience designers watch representative users attempt tasks on a prototype or the actual interface of a product. The researcher observes the user to determine what is obvious and what confuses the user. In particular, the user’s natural interaction with the system informs natural affordances for the user experience design. When the system deviates from user expectations, indicate opportunities for improved design. In Code Readability Testing, the product is the source code, and the user is another developer.
The ideal reader represents future developers and those who will maintain the system. For the typical team, developers on the same team serve as ideal readers. For an open source project, core developers and contributors serve as ideal readers. The ideal reader possesses experiences similar to those of the author, and is proficient with the programming language, framework, and libraries used. If programmers expect their code to be routinely read by less experienced programmers, then novices would be ideal readers.

\section{Field Study}
The researcher followed the Code Readability Testing with each programmer in four separate one-on-one sessions to assess effectiveness and observe improvements over time. The programmers were 21 master students enrolled in the ``Craft of Software Development" course at Carnegie Mellon University in Silicon Valley during the Spring 2013 semester.

The researcher scheduled each session for thirty minutes, spaced three weeks apart, thus producing 84 data points. For each session, the researcher asked the students to bring ``production ready" code, software that was ready to be released on a real project. The students selected their own projects to work on. At the end of each session, the researcher recorded the review’s duration, the number and type of issues detected, and assessment of the overall readability score.

The student’s professional development experience ranged from zero to eight years. The average number of years of experience was three years.

\subsection{Readability Score}
This paper defines code readability as the amount of mental effort required to understand the code. After examining the code, the researcher assigned a readability score following this scale:
\begin{etaremune}
  \item Easy to read
  \item Pretty easy to read
  \item Medium difficulty
  \item Very challenging
\end{etaremune}
  
In existing studies [13, 16, 24, 27, 29], there is no standard readability definition or score. In both the Buse and Dorn studies, participants rate code on a Likert scale from ``very unreadable" 1 to ``very readable" 5, from ``unreadable" to ``readable" [8, 14]. The participants define their own meaning for readable.

In using this scale, the researcher noticed that the duration of the review correlated with the amount of effort required. For example, reviewing ``easy to read" code didn’t take much time to review. The average length was 8 minutes with 4 minutes variance. Reviewing ``very challenging" to read code often consumed the whole session. The correlation between readability score and the time to review was 0.77

Typically ``easy to read" code presents the reader with a simple to follow narrative, keeping a few items in short term memory. ``Very challenging" code obscures the programmer’s intention. When the reader grabs a sheet of paper and manually executes the computer program by writing down variable values in order to understand the program logic, then the code is ``very challenging" to read.

There are common solutions to many programming problems. ``Very challenging" code might avoid typical solutions or typical constructs for a solution. When the code’s solution is different from the reader’s expectation for the solution, the reader finds the code ``very challenging."

After reviewing the data, the researcher grouped ``Pretty easy to read" and ``Easy to read" code samples as ``readable" code and groups ``Very challenging" and ``medium difficulty" code samples as ``unreadable" code. For unreadable code, the code clearly required rework before submission on a project. When comparing these two groups, the code samples were indeed, night and day.

\section{Results}
Research Question 1: Would programmers who repeatedly follow Code Readability Testing increase the readability of their code?
After graphing trends in the data, the researcher lumped the data into four groups: programmers who initially wrote readable code and made small improvements, programmers who initially wrote unreadable code and made large improvements, programmers whom initially wrote unreadable code and continued to do so, and programmers whose results are not clear.

\begin{table}[!t]
\renewcommand{\arraystretch}{1.3}
\caption{A Simple Example Table}
\label{table_example}
\centering
\begin{tabular}{l||r}
\hline
\bfseries Result & \bfseries Count\\
\hline\hline
Readable to readable (with small improvements) & 11\\
\hline
Unreadable to readable (with large improvements) & 5\\
\hline
Unreadable to unreadable & 1\\
\hline
Results are not clear & 4\\
\hline
Total & 21\\
\hline
\end{tabular}
\end{table}

Starting from the first session, 11 of the programmers wrote readable code consistently. While small improvements can be made to the code, the reader easily understood the code. Of these 11, five progressed from ``pretty easy to read" to ``easy to read" as represented by Figure 1. The process did not hurt the programmer’s ability to write code.

Five programmers initially produced ``unreadable code" but over time started improving and finished by writing ``readable code" as illustrated by Figure 2. For some, immediate changes occurred, whereas for one programmer, the change required a few sessions.

One programmer consistently wrote ``unreadable code" during each session as shown in Figure 3. While the programmer improved variable and method naming, the programmer ignored feedback such as breaking multiple nested for loops and if statements. Instead of taking the time to increase readability, the participant reasoned, ``I want my code to be as efficient as possible." (Ironically, by only making readability improvements, the readable code was more efficient than the original code.)

Four of the data plots were ``all over the place." While two of them trended towards more ``readable code," the researcher classified them as outliers. Considering the entire sample size, this means that 16 of the 21 programmers improved their ability to write readable code. When considering the 10 programmers who could benefit from improving readability testing, five achieved large improvements.

Looking only at the first and last sessions, then an interesting result emerged. During the first session, 13 programmers wrote readable code and all still wrote readable code at the end. During the first session, eight programmers wrote unreadable code, and at the end two wrote unreadable code, and six wrote readable code.

\textbf{Result 1:} Most programmers who write ``unreadable" code significantly improve and start writing ``readable" code after four sessions. Programmers who initially write ``readable" code also improve their ability to write readable code.

Research Question 2: What kinds of issues does Code Readability Testing detect?

In reviewing the notes on the 84 sessions, the researcher classified suggestions and feedback based upon feedback type. The researcher relied on unstructured interview notes, not an inspection checklist. The following table prioritizes the feedback by the frequency of each feedback type across all 84 sessions. For example, 45 of the 84 reviews mentioned altering the name of variables as a means improve readability.

\begin{table}[!t]
\renewcommand{\arraystretch}{1.3}
\centering
\begin{tabular}{l||l}
\hline
\bfseries Improve code readability by & \bfseries Number of Reviews\\
\hline\hline
Improving variable names                  & 45 / 84           \\ \hline
Improving method names                    & 25/ 84            \\ \hline
Extract method to reduce code duplication & 26 / 84           \\ \hline
Simplifying if conditions                 & 10 / 84           \\ \hline
Reducing if nesting                       & 11 / 84           \\ \hline
Simplifying loop conditions               & 11 / 84           \\ \hline
Reducing loop structures                  & 5 / 84            \\ \hline
Improving class names                     & 3 / 84            \\ \hline
Re-sequencing method arguments            & 1 / 84            \\ \hline
Simplifying data structures               & 1 / 84            \\ \hline
\end{tabular}
\end{table}

Although not a specific goal, readability testing found nine defects in eight of the code samples.

\textbf{Result 2:} Readability testing detects readability issues that are solved by improvements to variable names, improvements to method names, the creation of new methods to reduce code duplication, simplifying if conditions and nesting of if statements, and simplifying loop conditions.

Research Question 3: How time-consuming is readability testing?
The reader’s subjective experience was that processing ``easy to read" code was not time consuming. If a system is composed entirely of ``easy to read" code, then the overhead of this process is small. If a system has ``very challenging" sections of code, then it is worth reviewing. When the reviewer detects unreadable code, terminating the process allows a discussion of ways to improve code readability.

\begin{table}[!t]
\renewcommand{\arraystretch}{1.3}
\centering
\begin{tabular}{l||r}
\hline
\bfseries Readability Score & \bfseries Median time on review\\
\hline\hline
Very challenging    & * 30 minutes \\
Medium difficulty   & 20 minutes   \\
Pretty easy to read & 11 minutes   \\
Easy to read        & 8 minutes  
\end{tabular}
\end{table}

Note: the sessions were limited to 30 minutes, the length of the meeting. Often another session was scheduled after any given session. If the reader could not understand the code after 30 minutes, the session was ended.

\textbf{Result 3:} For readable code, readability testing is straightforward. For unreadable code, the process takes significant time. Once unreadable code is detected, the reader and the author can agree that the code needs rework and end the session early.

\textbf{The Programmers’ Perceptions}
Research Question 4: How did programmers perceive Code Readability Testing?

At the end of the four sessions, the programmers answered an anonymous survey about their experience with 20 of the 21 participants completing the survey. The self-assessment exposes the programmers’ perception of the technique.

Question: ``Was it worth your time or not worth your time?" 20 out of 20 say that following the process was worth their time.

Question: ``Why was it worth or why was it not worth your time?" The free-text responses were grouped according to themes. If participants mentioned multiple reasons, then each reason counts in each theme.

\begin{table}[!t]
\renewcommand{\arraystretch}{1.3}
\centering
\begin{tabular}{l||l}
\hline
\bfseries Code Readability Testing... & \bfseries Count\\
\hline\hline
allows me to see areas of improvement to increase code readability    & 9 \\
allows me to see a different perspective on my code & 7   \\
provides guidance by someone with more experience & 4   \\
motivates me to improve the readability of my code & 3 \\
allows me to know if my code was understandable & 3 \\
allows me to improve my programming speed & 1 \\
increases collaboration of software development process & 1 
\end{tabular}
\end{table}

Question: ``Did you learn how another developer reads and understands your code?"
Out of the 20 participants, 18 participants said yes, and two skipped the question.

Question: ``How has this affected the way you write software?"

\begin{table}[!t]
\renewcommand{\arraystretch}{1.3}
\centering
\begin{tabular}{l||l}
\hline
\bfseries I now... & \bfseries Count\\
\hline\hline
choose clearer variable and method names    & 9 \\
consider the needs of future readers & 7   \\
think about the code narrative & 5   \\
write shorter methods & 2 \\
don’t repeat yourself (DRY) & 2 \\
avoid deep nested if-else logic & 1 \\
re-read code before committing & 1 \\
isolate complex logic into a method & 1
\end{tabular}
\end{table}

Questions: ``Did you see the reader struggle with understanding your code?"
Out of the 20 participants, 10 participants said yes.

Question: ``If so, how did it make you feel?"

\begin{table}[!t]
\renewcommand{\arraystretch}{1.3}
\centering
\begin{tabular}{l||l}
\hline
\bfseries I am... & \bfseries Count\\
\hline\hline
motivated to write more readable code    & 5 \\
inspired as it was revealing and insightful & 4  
\end{tabular}
\end{table}

\textbf{Result 4:} Programmers think following readability testing is worth their time. Their ability to write readable code increases. They articulate concrete improvements to the way they write code. When programmers see a reader struggle to understand their code, the programmers are willing to write readable code and inspired by another developer’s point of view.

\section{Threats to Validity}
\subsection{Construct Validity}
Code Readability Testing has the reviewer ``think aloud" as they read through the code. The ``think aloud" activity might not mirror the process a programmer uses when they read code to themselves.
\subsection{Internal Validity}
\begin{enumerate}
  \item The selection of the reviewer – in order to remove the difficulty of inter-reviewer reliability, there is only one reviewer in this study. The reviewer is the researcher, which leads to possible researcher bias. The results might change with a different reviewer. Another reviewer might find more or fewer issues. Another reviewer might be more or less experienced at reading other people’s code.

The reviewer has professional experience in C, C++, Java, and Ruby. The reviewer is able to read and understand the provided C#, Javascript, Objective C, Python, and Dart code. When the reviewer did not understand programming language syntax or idioms, the reviewer asks the author for clarification. While the reviewer is able to understand Javascript code, a more experienced Javascript programmer might find issues not detected.
  \item The selection of programming assignments – the programmers select what to work on. The difficulty level of each session might not be consistent.
  \item The selection of programming languages – this study verifies that the approach works within a variety of programming languages and problem domains. For future research, constraining to a particular language may yield stronger insights.
  \item Influence from other graduate courses – discussions in the concurrent metrics course and the craft of software development course about code quality might affect the results by sensitizing students to the need to write readable code.
\end{enumerate}

\subsection{External Validity}
The participants were master of software engineering students. Their professional development experience ranged from zero to eight years. The average number of years of experience was three years. The correlation between years of industry experience and improvement was 0.31 showing little relationship between improvement and years of industry experience. In fact, the two participants with the most industry experience (seven years and eight years) both dramatically improved their ability to write readable code. Since all the students were still at the beginning of their careers, the drastic improvements in writing readable code might not transfer to more experienced programmers.

\section{Future Research}
Several of the programmers appreciate the value a more experienced developer providing feedback. Future work could reveal the results when the reader and the author possess similar expertise, or if the reader possesses less expertise than the author. If code needs to be readable by less experienced peers, then learning how less experienced programmers read code should contain valuable feedback.

Removing the researcher from the reader role would remove researcher bias. Perhaps students could act as readers for each other if they’re given training.

Future work could entail a direct analysis between code reviews and readability testing. Next time, all the programmers could finish the same programming exercise and the researcher could directly compare the results from the two techniques.

One subject persistently wrote ``unreadable" code. The subject defended his strategy because ``I want my code to be as efficient as possible." Future work could examine how prevalent is this attitude of writing ``efficient" but unreadable code, determine where its origins, and suggest possible mitigation steps. In 1974, Knuth proclaimed that premature optimization is the root of all evil [20], yet the problem remains today.

\section{Conclusions}
Code readability testing addresses the question, ``Is my code readable?" by exposing the thought process of a peer reading the code. In this study, 21 programmers followed Code Readability Testing in four sessions. Most programmers writing ``difficult to read" code became programmers writing ``easy to read" code after three sessions. Programmers writing ``easy to read" code improved their skill. This study identifies several common fixes to unreadable code including improvements to variable names, improvements to method names, the creation of new methods to reduce code duplication, simplifying if conditions and structures, and simplifying loop conditions. The programmers reported that the technique is worth their time and articulated how readability testing alters their programming habits.

% An example of a floating figure using the graphicx package.
% Note that \label must occur AFTER (or within) \caption.
% For figures, \caption should occur after the \includegraphics.
% Note that IEEEtran v1.7 and later has special internal code that
% is designed to preserve the operation of \label within \caption
% even when the captionsoff option is in effect. However, because
% of issues like this, it may be the safest practice to put all your
% \label just after \caption rather than within \caption{}.
%
% Reminder: the "draftcls" or "draftclsnofoot", not "draft", class
% option should be used if it is desired that the figures are to be
% displayed while in draft mode.
%
%\begin{figure}[!t]
%\centering
%\includegraphics[width=2.5in]{myfigure}
% where an .eps filename suffix will be assumed under latex, 
% and a .pdf suffix will be assumed for pdflatex; or what has been declared
% via \DeclareGraphicsExtensions.
%\caption{Simulation results for the network.}
%\label{fig_sim}
%\end{figure}

% Note that the IEEE typically puts floats only at the top, even when this
% results in a large percentage of a column being occupied by floats.


% An example of a double column floating figure using two subfigures.
% (The subfig.sty package must be loaded for this to work.)
% The subfigure \label commands are set within each subfloat command,
% and the \label for the overall figure must come after \caption.
% \hfil is used as a separator to get equal spacing.
% Watch out that the combined width of all the subfigures on a 
% line do not exceed the text width or a line break will occur.
%
%\begin{figure*}[!t]
%\centering
%\subfloat[Case I]{\includegraphics[width=2.5in]{box}%
%\label{fig_first_case}}
%\hfil
%\subfloat[Case II]{\includegraphics[width=2.5in]{box}%
%\label{fig_second_case}}
%\caption{Simulation results for the network.}
%\label{fig_sim}
%\end{figure*}
%
% Note that often IEEE papers with subfigures do not employ subfigure
% captions (using the optional argument to \subfloat[]), but instead will
% reference/describe all of them (a), (b), etc., within the main caption.
% Be aware that for subfig.sty to generate the (a), (b), etc., subfigure
% labels, the optional argument to \subfloat must be present. If a
% subcaption is not desired, just leave its contents blank,
% e.g., \subfloat[].


% An example of a floating table. Note that, for IEEE style tables, the
% \caption command should come BEFORE the table and, given that table
% captions serve much like titles, are usually capitalized except for words
% such as a, an, and, as, at, but, by, for, in, nor, of, on, or, the, to
% and up, which are usually not capitalized unless they are the first or
% last word of the caption. Table text will default to \footnotesize as
% the IEEE normally uses this smaller font for tables.
% The \label must come after \caption as always.
%
%\begin{table}[!t]
%% increase table row spacing, adjust to taste
%\renewcommand{\arraystretch}{1.3}
% if using array.sty, it might be a good idea to tweak the value of
% \extrarowheight as needed to properly center the text within the cells
%\caption{An Example of a Table}
%\label{table_example}
%\centering
%% Some packages, such as MDW tools, offer better commands for making tables
%% than the plain LaTeX2e tabular which is used here.
%\begin{tabular}{|c||c|}
%\hline
%One & Two\\
%\hline
%Three & Four\\
%\hline
%\end{tabular}
%\end{table}


% Note that the IEEE does not put floats in the very first column
% - or typically anywhere on the first page for that matter. Also,
% in-text middle ("here") positioning is typically not used, but it
% is allowed and encouraged for Computer Society conferences (but
% not Computer Society journals). Most IEEE journals/conferences use
% top floats exclusively. 
% Note that, LaTeX2e, unlike IEEE journals/conferences, places
% footnotes above bottom floats. This can be corrected via the
% \fnbelowfloat command of the stfloats package.



% trigger a \newpage just before the given reference
% number - used to balance the columns on the last page
% adjust value as needed - may need to be readjusted if
% the document is modified later
%\IEEEtriggeratref{8}
% The "triggered" command can be changed if desired:
%\IEEEtriggercmd{\enlargethispage{-5in}}

% references section

% can use a bibliography generated by BibTeX as a .bbl file
% BibTeX documentation can be easily obtained at:
% http://mirror.ctan.org/biblio/bibtex/contrib/doc/
% The IEEEtran BibTeX style support page is at:
% http://www.michaelshell.org/tex/ieeetran/bibtex/
%\bibliographystyle{IEEEtran}
% argument is your BibTeX string definitions and bibliography database(s)
%\bibliography{IEEEabrv,../bib/paper}
%
% <OR> manually copy in the resultant .bbl file
% set second argument of \begin to the number of references
% (used to reserve space for the reference number labels box)
% \begin{thebibliography}{1}

% \bibitem{IEEEhowto:kopka}
% H.~Kopka and P.~W. Daly, \emph{A Guide to \LaTeX}, 3rd~ed.\hskip 1em plus
%   0.5em minus 0.4em\relax Harlow, England: Addison-Wesley, 1999.

% \end{thebibliography}

\bibliographystyle{IEEEtran}
\bibliography{bibliography_code_readability.bib}


% that's all folks
\end{document}


